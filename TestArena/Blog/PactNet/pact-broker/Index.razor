@page "/blog/integration-with-pactflow"
@using TestArena.Blog.Common

<BlogContainer>
    <Header 
        Title="Intro to PACT for .NET Core: Integration with PactFlow"
        Image="/images/blog/pact/pact-broker/blog_header.png"
        PublishedOn="@DateTime.Now"
        Authors="Ajay Kumar" />

    <Section Heading="Introduction">
        <p>This is in continuation of PACT for .NET series where we will be looking into one of the ways to integrate our APIs with PactFlow.</p>
        <p>For a short introduction, PactFlow is a platform that can act as a broker between consumers and providers services/systems. Consumers can push/upload the contracts to PactFlow and provider systems can read the same contracts and try to verify them.</p>
        <p>In PactFlow one can visualise failing/passing contracts, total contract integrations, dependency graph and much more. For a better read please visit <a href="https://pactflow.io/">https://pactflow.io/</a></p>
        <p>You need to register into pact for for a limited free or paid account. For this demo i am using free account that can support up to 2 contracts as per their docs.</p>
        <p>Now, for this article we will be following the same Student and Result API scenario, where student is the Provider service and Result service is the consumer service.</p>
    </Section>

    <p>To learn more about demo repo that we will be using in this article, please follow previous articles in this series:</p>
    <BlogReferenceCard 
        Title="Contract testing for APIs: Intro to PACT for .NET Core"
        Description="Intro to PACT for .NET Core: API contract testing"
        Url="/blog/contract-testing-pact-net-intro"
        ImageUrl="/images/blog/pact/intro/header_landscape.png"
        Source="devcodex.in"/>
    <BlogReferenceCard 
        Title="Intro to PACT for .NET Core: Events Based Systems"
        Description="Intro to PACT for .NET Core: Events Based Systems"
        Url="/blog/contract-testing-in-pact-with-events"
        ImageUrl="/images/blog/pact/events-demo/contract-testing-events.webp"
        Source="devcodex.in"/>

    <Section Heading="Consumer Side">
        <p>Once the PACT contract file is generated by the consumer, there are several ways we can push or upload the contract to PactFlow. You can read about all the ways at <a href="https://docs.pact.io/getting_started/sharing_pacts">https://docs.pact.io/getting_started/sharing_pacts</a>.</p>
        <p>For this post, I have used a combination of their REST APIs and the PactNet library.</p>
        <p>The below utility code uploads the contract file to the Pact broker. Among all the parameters, it requires the Pact broker base URI and read/write access token for authentication to the Pact broker. You can obtain this information by logging into your PactFlow account and reaching out to the settings section.</p>

        <BlogImage ImagePath="/images/blog/pact/pact-broker/PactFlow settings section.webp" Description="PactFlow settings section" Number="1" />

        <CodeSnippet Number="1" Description="Code to push pact contract file to pact flow">
// Code to push pact contract file to pact flow
using System.Net;
using System.Net.Http.Headers;
using System.Text;

namespace PactNet.ConsumerOne.UnitTest.Utilities;

public abstract class PactBrokerUtiliy
{
    private const string PactSubUrl = "{0}/pacts/provider/{1}/consumer/{2}/version/{3}";
    
    public static async Task&lt;HttpStatusCode&gt; PublishPactContract(string pactFlowBaseUri,string consumerName, string providerName, string contractJson, string accessToken, string consumerVersion = "")
    {
        var httpClient = new HttpClient();
        httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("bearer", accessToken);
        var fullUrl = string.Format(PactSubUrl, pactFlowBaseUri, providerName, consumerName, string.IsNullOrEmpty(consumerVersion) ? Guid.NewGuid() : consumerVersion);

        var response =
            await httpClient.PutAsync(fullUrl, new StringContent(contractJson, Encoding.UTF8, "application/json"));
        var responseContent = await response.Content.ReadAsStringAsync();
        return response.StatusCode;
    }
}
        </CodeSnippet>

        <p>Now we can use this utility method after the pact contract file is generated by the consumer. Some thing like below</p>

        <CodeSnippet Number="2" Description="Code excerpt from ReportCardApiPactFlowTest.cs class">
            // Code excerpt from ReportCardApiPactFlowTest.cs class
[Fact]
public async Task Get_Student_When_The_StudentId_Is_Invalid()
{
    // Arrange
    _pactBuilder
    .UponReceiving("A GET request to retrieve the student with invalid student id")
    .Given("There is student is at least one valid student present")
    .WithRequest(HttpMethod.Get, "/students/some-invalid-id")
    .WithHeader("Accept", "application/json")
    .WillRespond()
    .WithStatus(HttpStatusCode.NoContent);

     _pactBuilder.Verify(ctx =>
     {
         // Act
         var client = new StudentClient(ctx.MockServerUri);
         Assert.ThrowsAsync&lt;Exception&gt;(async () => await client.GetStudentById("some-invalid-id"));
     });
            
     await UploadPactContract();
}

private static async Task UploadPactContract()
{
    var pactPath = Path.Combine("..",
        "..",
        "..",
        "..",
        "pacts",
        "ConsumerOne-Student API.json");

        var contractJson = File.ReadAllText(pactPath);
        var pactFlowBaseUri = Environment.GetEnvironmentVariable("PACT_FLOW_BASE_URL"); // For testing purposes, you may even hardcode this value
        var pactFlowToken = Environment.GetEnvironmentVariable("PACT_FLOW_TOKEN"); // For testing purposes, you may even hardcode this value
        var statusCode = await PactBrokerUtiliy.PublishPactContract(
            pactFlowBaseUri,
            "ConsumerOne",
            "Student API",
            contractJson,
            pactFlowToken,
            Guid.NewGuid().ToString());
}
        </CodeSnippet>

        <p>You may notice that i have used environment variables at few places. This is to avoid mentioning account details that i have used.</p>

        <CodeSnippet Number="3" Description="Code to read environment variables">
Environment.GetEnvironmentVariable("PACT_FLOW_BASE_URL");
// It will translate to something like https://your_account_name.pactflow.io

Environment.GetEnvironmentVariable("PACT_FLOW_TOKEN");
// It will translate to some random string
        </CodeSnippet>

        <p>If you are using it for demo purpose or learning you may also choose to hardcode these to the ones you obtained from pact flow settings page. In case you want to use the code as it is, then is must that you mention these environment variables before you run tests.</p>

        <p>After all these code changes and settings are in place, we can run the test and should expect a success. Following things will happen when we run the test.</p>

        <ul>
            <li>Our request verification and assertion will occur.</li>
            <li>Pact contract file will be generated at the specified location.</li>
            <li>The same Pact file content will be read and passed on to the utility method to be sent as payload to HTTP request to PactFlow.</li>
        </ul>

        <p>Once the test is green, we can head to pact flow home page to see if any integrations (consumer-provider)/contracts have been uploaded or not. If everything is in order, we should be able to see something like below screenshot.</p>

        <BlogImage ImagePath="/images/blog/pact/pact-broker/Student API and its consumer integration in pact flow.webp" Description="Student API and its consumer integration in pact flow" Number="2" />

        <p>If you observe the above image, we can see the contract is there, but its in unverified mode. It is because this pact has not been verified yet by the provider. We can see verification in action next.</p>
    </Section>

    <Section Heading="Provider Side">
        <p>Provider side verification is relatively straightforward. The following unit test in the provider's unit test class ensures compliance with the contract.</p>

        <CodeSnippet Number="4" Description="Code to verify pact contract">
[Fact]
public void Ensure_StudentApi_Honours_Pact_With_ConsumerOne_Using_PactFlow()
{
     // Arrange
     var config = new PactVerifierConfig
     {
        Outputters = new List&lt;IOutput&gt;
        {
            new XunitOutput(_output),
        },
        LogLevel = PactLogLevel.Information
     };

     var pactFlowBaseUri = Environment.GetEnvironmentVariable("PACT_FLOW_BASE_URL"); // For testing purposes, you may even hardcode this value
     var pactFlowToken = Environment.GetEnvironmentVariable("PACT_FLOW_TOKEN"); // For testing purposes, you may even hardcode this value

     // Act // Assert
     IPactVerifier pactVerifier = new PactVerifier(config);
     pactVerifier
         .ServiceProvider("Student API", _fixture.ServerUri)
         .WithPactBrokerSource(new Uri(pactFlowBaseUri), configure =>
         {
             configure.TokenAuthentication(pactFlowToken);
             configure.PublishResults(true, "1.0.0"); // Any version
         })
         .WithProviderStateUrl(new Uri(_fixture.ServerUri, "/provider-states"))
         .Verify();
  }
        </CodeSnippet>

        <CodeSnippet Description="The below piece of code is the key in verification with pact flow as source" Number="5">
// The below piece of code is the key in verification with pact flow as source
.WithPactBrokerSource(new Uri(pactFlowBaseUri), configure =>
{
     configure.TokenAuthentication(pactFlowToken);
     configure.PublishResults(true, "1.0.0"); // Any version
})
        </CodeSnippet>
        <p>Now finally after all this setup in place. If we run the pact provider test we should see the test being success, if we run it locally. Something like below.</p>

        <BlogImage ImagePath="/images/blog/pact/pact-broker/Pact flow success console logs.webp" Description="Pact flow success console logs" Number="3" />

        <p>As a result of this we should also be able to see that the pact integration that was showing as unverified earlier has changed to verified.</p>

        <BlogImage ImagePath="/images/blog/pact/pact-broker/Pact verification success in pact flow.webp" Description="Pact verification success in pact flow" Number="4" />

        <BlogImage ImagePath="/images/blog/pact/pact-broker/Image mentioning that the interactions have been passed.webp" Description="Image mentioning that the interactions have been passed" Number="5" />
        </Section>

    <Section Heading="Failure scenario!">
        <p>Lets make some changes in our code to deliberately make the code fail. For demo we can change the student service to return <code>firstName1</code> property in the response instead on <code>firstName</code> as expected by consumer service. After making this change, when the unit test is run, we can see the below result in pact verification.</p>

        <BlogImage ImagePath="/images/blog/pact/pact-broker/Pact flow failure.webp" Description="Pact flow failure" Number="6" />
        <BlogImage ImagePath="/images/blog/pact/pact-broker/Pact flow failure details.webp" Description="Pact flow failure details" Number="7" />
    </Section>
    <EndNotes RepositoryLink="https://github.com/ajaysskumar/pact-net-example"/>
</BlogContainer>
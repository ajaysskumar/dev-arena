@page "/blog/tdd/introduction"
@using TestArena.Blog.Common
@using TestArena.Blog.Common.NavigationUtils

<style>
    table {
      border-collapse: collapse;
      width: 100%;
      margin: 20px 0;
    }
    th, td {
      padding: 12px;
      border: 1px solid #ddd;
      text-align: left;
    }
    th {
      background-color: #f0f0f0;
    }
  </style>

@code{
  PageInfo currentPage = SiteMap.Pages.FirstOrDefault(x => x.RelativePath == "/blog/tdd/introduction");
}

<BlogContainer>


  <Header Title="Test Driven Development (TDD): A Practical Introduction"
      Image="@currentPage.ArticleImage" PublishedOn="@currentPage.PublishedOn" Authors="Ajay Kumar">
  </Header>

  <Section>
    <p>Test Driven Development (TDD) is a disciplined approach to software development where you write tests <b>before</b> you write the code. Instead of coding and hoping nothing breaks, TDD gives you a safety net and a clear workflow for building robust features.</p>
    <p>In this post, we’ll break down the TDD cycle, address common misconceptions, and walk through a simple example in C#.</p>
  </Section>

  <Section Heading="The TDD Cycle: Red, Green, Refactor">
    <ul>
      <li><b>Red:</b> Write a test for a new feature. It should fail, since the feature doesn’t exist yet.</li>
      <li><b>Green:</b> Write the minimum code needed to make the test pass.</li>
      <li><b>Refactor:</b> Clean up the code, keeping all tests green.</li>
    </ul>
    <p>This loop is repeated for every new piece of functionality. It’s simple, but it fundamentally changes how you design and maintain code.</p>
  </Section>

  <Section Heading="Common Myths About TDD">
    <ul>
      <li><b>“TDD slows you down.”</b> It may feel slower at first, but it saves hours of debugging and regression fixes in the long run.</li>
      <li><b>“TDD is just about testing.”</b> Actually, TDD is a design technique. Tests guide your architecture and help you write modular, maintainable code.</li>
      <li><b>“TDD only works for simple problems.”</b> TDD is even more valuable for complex domains, where breaking problems into small, testable steps is crucial.</li>
    </ul>
  </Section>

  <Section Heading="A Simple Example: Adding Two Numbers">
    <p>Let’s see TDD in action with a basic C# example. Suppose we want a method that adds two numbers.</p>
    <ol>
      <li><b>Write a failing test (Red):</b></li>
    </ol>
    <CodeSnippet Description="Failing test for Add method" Number="1">
using Xunit;

public class CalculatorTests
{
  [Fact]
  public void Add_TwoNumbers_ReturnsSum()
  {
    var calc = new Calculator();
    var result = calc.Add(2, 2);
    Assert.Equal(4, result);
  }
}
    </CodeSnippet>
    <p>This test fails because <code>Calculator</code> doesn’t exist yet.</p>
    <ol start="2">
      <li><b>Write minimal code to pass (Green):</b></li>
    </ol>
    <CodeSnippet Description="Minimal code to pass the test" Number="2">
public class Calculator
{
  public int Add(int a, int b) => a + b;
}
    </CodeSnippet>
    <p>Now the test passes. If the code is already clean, you may not need to refactor. In real projects, this is where you improve names, remove duplication, or reorganize logic—confident that your tests have your back.</p>
  </Section>

  <Section Heading="Why TDD Matters">
    <p>TDD isn’t about writing more tests. It’s about building confidence in your codebase, enabling safe refactoring, and letting tests drive better design decisions. The process scales from trivial methods to complex systems.</p>
  </Section>

  <Section>
    <p>In the next post, we’ll tackle a slightly more complex problem (like FizzBuzz or a String Calculator) and walk through the TDD process step by step.</p>
    <p>Have you tried TDD before? What worked, what didn’t? Share your experience in the comments below.</p>
  </Section>
</BlogContainer>
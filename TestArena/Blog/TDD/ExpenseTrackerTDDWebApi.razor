@page "/blog/tdd/expense-tracker-tdd-webapi-v2"
@using TestArena.Blog.Common
@using TestArena.Blog.Common.NavigationUtils

@code {
    PageInfo? currentPage = SiteMap.Pages.FirstOrDefault(x => x.RelativePath == "/blog/tdd/expense-tracker-tdd-webapi-v2");

    protected override void OnInitialized()
    {
        if (currentPage == null)
        {
            throw new InvalidOperationException("Page not found in SiteMap");
        }
        base.OnInitialized();
    }
}

<BlogContainer>
    <Header Title="TDD in .NET: Controller Layer with Expense Tracker Example"
            Image="@(currentPage?.ArticleImage)"
            PublishedOn="@(currentPage?.PublishedOn ?? DateTime.UtcNow)"
            IsOlderThumbnailFormat="@(currentPage?.IsOlderThumbnailFormat ?? true)"
            Authors="Ajay Kumar">
    </Header>

    <Section Heading="Introduction" Level="2">
        <p>
            In this article, we focus on applying Test-Driven Development (TDD) to the <b>controller layer</b> of a minimal Expense Tracker API in .NET. You'll see how to break down the use case, write tests for the controller, and drive implementation step-by-step. All code and narration are based on a real TDD diary, making the process easy to follow and practical.
        </p>
        <div class="tip">
            <b>Why start with controllers?</b> Controllers are the entry point for API requests. TDD here ensures your endpoints behave as expected and delegate correctly to the service layer.
        </div>
    </Section>

    <Section Heading="Use Case: Get Expenses by Category" Level="2">
        <ul>
            <li>Feature: Fetch all expenses for a given category (e.g., "Food", "Travel")</li>
            <li>API should return a list of matching expenses</li>
        </ul>
    </Section>

    <Section Heading="Step 1: Write a Failing Controller Test" Level="3">
        <p>
            We start by writing a test for the controller. The test checks that the endpoint returns a list of expenses for the requested category.
        </p>
        <CodeSnippet Language="csharp" Description="Controller test for GetExpensesByCategory">
[Fact]
public async Task GetExpensesByCategory_ReturnsExpensesForCategory()
{
    // Arrange
    var mockService = new Mock&lt;IExpenseService&gt;();
    var category = "Food";
    var expected = new List&lt;ExpenseDto&gt; {
        new ExpenseDto { Title = "Lunch", Amount = 10, Category = "Food", Date = DateTime.Today },
        new ExpenseDto { Title = "Snacks", Amount = 5, Category = "Food", Date = DateTime.Today }
    };
    mockService.Setup(s =&gt; s.GetExpensesByCategoryAsync(category)).ReturnsAsync(expected);
    var controller = new ExpensesController(mockService.Object);

    // Act
    var result = await controller.GetExpensesByCategory(category);

    // Assert
    var okResult = Assert.IsType&lt;OkObjectResult&gt;(result);
    var actual = Assert.IsAssignableFrom&lt;IEnumerable&lt;ExpenseDto&gt;&gt;(okResult.Value);
    Assert.Equal(expected.Count, actual.Count());
}
        </CodeSnippet>
        <div class="gotcha">
            <b>Tip:</b> The test will fail at first, because the endpoint does not exist yet. This is the "Red" phase of TDD.
        </div>
    </Section>

    <Section Heading="Step 2: Make the Test Compile (Add Endpoint)" Level="3">
        <p>
            Next, we add the minimum code to the controller to define the endpoint and make the test compile.
        </p>
        <CodeSnippet Language="csharp" Description="Controller endpoint for GetExpensesByCategory">
[HttpGet("category/{category}")]
public async Task&lt;IActionResult&gt; GetExpensesByCategory(string category)
{
    var expenses = await _service.GetExpensesByCategoryAsync(category);
    return Ok(expenses);
}
        </CodeSnippet>
        <div class="design-insight">
            <b>Design Insight:</b> Thin controllers delegate work to the service layer. This keeps your API endpoints simple and maintainable.
        </div>
    </Section>

    <Section Heading="Step 3: Add Service Method (Just Enough to Pass)" Level="3">
        <p>
            The controller calls a service method. We add just enough code to make the test compile and run, returning an empty list for now.
        </p>
        <CodeSnippet Language="csharp" Description="Service method stub">
// IExpenseService
Task&lt;IEnumerable&lt;ExpenseDto&gt;&gt; GetExpensesByCategoryAsync(string category);

// ExpenseService
public async Task&lt;IEnumerable&lt;ExpenseDto&gt;&gt; GetExpensesByCategoryAsync(string category)
{
    // For now, return an empty list to make the test compile
    return new List&lt;ExpenseDto&gt;();
}
        </CodeSnippet>
        <div class="tip">
            <b>TDD Principle:</b> Only write enough code to make the test pass. Refactor later as needed.
        </div>
    </Section>

    <Section Heading="Step 4: Run the Test and Refactor" Level="3">
        <p>
            After fixing missing using directives and method signatures, the test passes. The controller correctly delegates to the service and returns the expected data.
        </p>
        <blockquote>
            <b>Test Run Log:</b>
            <pre>
Test summary: total: 1, failed: 0, succeeded: 1, skipped: 0, duration: 0.6s
            </pre>
        </blockquote>
        <div class="challenge">
            <b>Challenge:</b> Try changing the test data or category to see how the controller responds. TDD makes it easy to adapt and extend your API.
        </div>
    </Section>

    <Section Heading="Lessons Learned" Level="2">
        <ul>
            <li>Start with a failing test to drive your API design</li>
            <li>Controllers should be thin and delegate to services</li>
            <li>Write just enough code to pass each test, then refactor</li>
            <li>Document each step and test run for clarity</li>
        </ul>
    </Section>

    <Section Heading="Summary" Level="2">
        <p>
            This article demonstrated TDD for the controller layer of a .NET Expense Tracker API. By following the diary-based approach, you can build robust, maintainable endpoints and understand the value of incremental, test-driven development.
        </p>
    </Section>
</BlogContainer>

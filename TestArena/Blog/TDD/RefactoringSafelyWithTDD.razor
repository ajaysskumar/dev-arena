@page "/blog/tdd/refactoring-safely-with-tdd"
@using TestArena.Blog.Common
@using TestArena.Blog.Common.NavigationUtils

@code {
    PageInfo? currentPage = SiteMap.Pages.FirstOrDefault(x => x.RelativePath == "/blog/tdd/refactoring-safely-with-tdd");

    protected override void OnInitialized()
    {
        if (currentPage == null)
        {
            throw new InvalidOperationException("Page not found in SiteMap");
        }
        base.OnInitialized();
    }
}

<BlogContainer>
    <Header Title="@(currentPage?.Header)"
            Image="@(currentPage?.ArticleImage)"
            PublishedOn="@(currentPage?.PublishedOn ?? DateTime.UtcNow)"
            IsOlderThumbnailFormat="@(currentPage?.IsOlderThumbnailFormat ?? true)"
            Authors="Ajay Kumar">
    </Header>

    <Section Heading="Why Developers Fear Refactoring (But Shouldn’t)" Level="4">
        <p>
            Picture this: You join a new team, and your first task is to fix a bug in a legacy billing module. The method is 300 lines long, filled with cryptic variable names and nested ifs. You hesitate—what if you break something? This fear is universal. But with a solid suite of tests, refactoring transforms from a risky gamble into a safe, even enjoyable, process. Tests are your safety net, letting you clean up code with confidence.
        </p>
        <b>Imagine a scenario:</b> You inherit an 8-year-old payment processing function mixing currency conversion, platform fees, and tax logic. Write 18 characterization tests covering edge cases. Now refactor safely: split into `CalculatePlatformFee()`, `ApplyTaxes()`, `ConvertCurrency()`. Tests verify all three work together.
    </Section>
    <Section Heading="How to Decide What to Refactor First" Level="4">
        <p>
            Not sure where to start? Focus your refactoring efforts where they’ll have the biggest impact:
        </p>
        <ul>
            <li><b>High-churn areas:</b> Code that changes often is more likely to accumulate bugs and technical debt. Clean it up first.</li>
            <li><b>Pain points:</b> Functions or modules that frustrate you or your team—slow to understand, hard to modify, or error-prone.</li>
            <li><b>Repetitive code:</b> Copy-pasted logic or duplicated patterns are prime candidates for extraction and simplification.</li>
            <li><b>Frequent bugs:</b> If a part of the codebase is always breaking, refactor it to make future fixes easier.</li>
        </ul>
        <CalloutBox Type="info">
            <b>Tip for juniors:</b> Start small. Refactor a single function or file, and build confidence as your tests protect you.
        </CalloutBox>
    </Section>

    <Section Heading="What Refactoring Really Means (and Why It’s Hard)" Level="4">
        <p>
            Refactoring isn’t rewriting, slowing down, or sneaking in new features. It’s about <b>improving the internal structure without changing what the code does</b>. The challenge? Sometimes the code is so tangled, or so poorly tested, that even small changes feel risky. If you’ve ever tried to clean up a function and ended up breaking something, you know the pain.
        </p>
        <b>Example:</b> Discount logic is duplicated in `OrderService`, `CartService`, and `QuoteService`. Write 24 tests covering percentage, flat-rate, seasonal, and tier-based discounts. Extract a single `DiscountCalculator` class. Now one bug fix to senior-citizen discounts benefits all three services.
    </Section>

    <Section Heading="The Golden Rule of Refactoring" Level="4">
        <blockquote>
            <b>If it’s not covered by tests, don’t refactor it.</b>
        </blockquote>
        <div style="text-align:center; margin: 1.5em 0;">
            <svg width="100%" height="80" viewBox="0 0 500 80" style="max-width:100%;">
                <rect x="10" y="20" width="120" height="35" rx="8" fill="#e0e7ef" stroke="#6b7280" stroke-width="2" />
                <text x="70" y="43" text-anchor="middle" font-size="13" fill="#222" font-weight="500">Legacy Code</text>
                
                <text x="150" y="45" font-size="20" fill="#6b7280" text-anchor="middle">→</text>
                
                <rect x="170" y="20" width="140" height="35" rx="8" fill="#e0e7ef" stroke="#6b7280" stroke-width="2" />
                <text x="240" y="43" text-anchor="middle" font-size="13" fill="#222" font-weight="500">Characterization Tests</text>
                
                <text x="330" y="45" font-size="20" fill="#6b7280" text-anchor="middle">→</text>
                
                <rect x="350" y="20" width="130" height="35" rx="8" fill="#e0e7ef" stroke="#6b7280" stroke-width="2" />
                <text x="415" y="43" text-anchor="middle" font-size="13" fill="#222" font-weight="500">Refactor Safely</text>
            </svg>
            <div style="font-size:13px; color:#555; margin-top:0.5em;">Workflow: Legacy Code → Characterization Tests → Refactor Safely</div>
        </div>
        <ol>
            <li>Identify what the code does (read, run, and document its outputs)</li>
            <li>Write tests that lock its current behavior (characterization tests)</li>
            <li>Refactor safely in tiny steps</li>
            <li>Run tests after every micro-change</li>
        </ol>
        <p>Tests are your seatbelts. If you don’t have them, write them first—even if they just confirm the current (possibly weird) behavior.</p>
        <CalloutBox Type="warning">
            <b>Tip:</b> Never refactor and add features in the same commit. Keep changes isolated.
        </CalloutBox>
    </Section>

    <Section Heading="Red → Green → Refactor, Explained Deeply" Level="4">
        <p>
            TDD (Test-Driven Development) makes refactoring a natural part of coding. Here’s how:
        </p>
        <ol>
            <li><b>Red:</b> Write a test for a new or existing behavior. Watch it fail (proves the test is valid).</li>
            <li><b>Green:</b> Make the test pass with the simplest code possible.</li>
            <li><b>Refactor:</b> Now, clean up the code. The tests guarantee you don’t break anything.</li>
        </ol>
        <p>
            <b>Example:</b> Express shipments should cost $15 flat, but are being charged weight-based rates. Red: `Assert.Equal(15, calculator.CalculateExpressShippingFee(anyWeight))` fails. Green: simplest fix. Refactor: introduce `ShippingStrategy` interface with implementations. Tests lock down both express and weight-tier rates working correctly.
        </p>
    </Section>

    <Section Heading="Practical Example — The Ugly Function Makeover" Level="4">
        <p>
            Let’s walk through a real-world scenario. You’re tasked with refactoring an API method that calculates discounts for a shopping cart. It’s a monster:
        </p>
        <ul>
            <li>150 lines long</li>
            <li>Duplicated logic for different product types</li>
            <li>Messy, nested conditionals</li>
            <li>No documentation</li>
        </ul>
        <p><b>Before (giant nested ifs):</b></p>
        <CodeSnippet Language="csharp" Description="Before Refactor: Giant Nested Ifs">
            public decimal CalculateDiscount(Cart cart)
            {
                if (cart.ProductType == "Electronics")
                {
                    if (cart.Price > 100)
                    {
                        return cart.Price * 0.9m;
                    }
                    else
                    {
                        return cart.Price * 0.95m;
                    }
                }
                else if (cart.ProductType == "Groceries")
                {
                    // ...more nested ifs...
                }
                // ...many more lines...
            }
        </CodeSnippet>
        <p><b>After (small clean methods):</b></p>
        <CodeSnippet Language="csharp" Description="After Refactor: Small Clean Methods">
            public decimal CalculateDiscount(Cart cart)
            {
                switch (cart.ProductType)
                {
                    case "Electronics":
                        return ApplyElectronicsDiscount(cart);
                    case "Groceries":
                        return ApplyGroceriesDiscount(cart);
                    default:
                        return cart.Price;
                }
            }

            private decimal ApplyElectronicsDiscount(Cart cart)
            {
                return cart.Price > 100 ? cart.Price * 0.9m : cart.Price * 0.95m;
            }
            // ...other clean methods...
        </CodeSnippet>
        <p>Here’s how you tackle it:</p>
        <ol>
            <li><b>Step 1:</b> Write tests confirming its current behavior (characterization tests). Example:</li>
        </ol>
        <CodeSnippet Language="csharp" Description="Characterization Test for Discount Calculation">
            // &lt;summary&gt;Verifies current discount logic for electronics&lt;/summary&gt;
            [Fact]
            public void Discount_Electronics_ShouldBe10Percent()
            {
                var cart = new Cart { ProductType = "Electronics", Price = 100 };
                var result = DiscountCalculator.Calculate(cart);
                Assert.Equal(90, result);
            }
        </CodeSnippet>
        <ol start="2">
            <li><b>Step 2:</b> Start micro-refactoring. Extract methods, rename variables, remove duplication, and introduce domain concepts. Example:</li>
        </ol>
        <CodeSnippet Language="csharp" Description="Extracting Method for Discount">
            // &lt;summary&gt;Extracted method for electronics discount&lt;/summary&gt;
            private decimal ApplyElectronicsDiscount(Cart cart)
            {
                return cart.Price * 0.9m;
            }
        </CodeSnippet>
        <ol start="3">
            <li><b>Step 3:</b> Keep running tests. If anything breaks, behavior changed—fix immediately. The tests will catch regressions before they reach production.</li>
        </ol>
        <b>Result:</b> The function shrinks to 40 lines, logic is clear, and future changes are easy.
    </Section>

    <Section Heading="When to Stop Refactoring" Level="4">
        <blockquote>
            <b>Boy Scout Rule:</b> Leave the code cleaner than you found it.
        </blockquote>
        <ul>
            <li>It’s readable</li>
            <li>Duplication is removed</li>
            <li>Structure makes sense</li>
            <li>No further clarity is gained</li>
        </ul>
        <b>Example</b> Your e-commerce checkout calculates shipping, taxes, and promo codes in one messy function. After extracting `CalculateShipping()`, `ApplyTaxes()`, and `ApplyPromoCode()` methods, the code is clear and each piece is testable. You stop there—no need for strategy patterns or caching yet. Tests pass, your teammate can modify it without fear. Boy Scout Rule satisfied.
    </Section>

    <Section Heading="Refactoring Patterns You Should Know" Level="4">
        <ul>
            <li>Extract Method</li>
            <li>Extract Class</li>
            <li>Inline Variable</li>
            <li>Rename for Intent</li>
            <li>Introduce Parameter Object</li>
            <li>Replace Magic Numbers with Constants</li>
            <li>Move Method</li>
            <li>Encapsulate Collection</li>
            <li>Replace Conditional with Polymorphism</li>
        </ul>
        <p>Learn a few — not all. Use them often. Try applying one pattern in your next refactor and see the difference.</p>
    </Section>

    <Section Heading="Common Gotchas & Anti-Patterns" Level="4">
        <ul>
            <li>Refactoring while adding new features</li>
            <li>Mixing feature changes and refactors in the same commit</li>
            <li>Editing tests to “make green” instead of fixing code</li>
            <li>Over-engineering</li>
            <li>Ignoring performance regressions</li>
        </ul>
        <p>
            <b>Example:</b> A junior dev refactors a password validation function from 80 lines to 20 lines (cleaner logic, same behavior). But they also "optimized" the regex pattern. Two days later, users can't reset passwords because the regex now rejects valid special characters. The refactor and the "optimization" are tangled. If separated: the refactor alone would pass all tests, and the optimization would immediately fail password tests. Lesson learned the hard way.
        </p>
    </Section>

    <Section Heading="Tools That Make Refactoring Easier" Level="4">
        <ul>
            <li>IDE automated refactorings (Rider/VS/IntelliJ)</li>
            <li>Mutation testing</li>
            <li>Linters & static analysis tools</li>
            <li>Coverage tools (for guidance, not targets)</li>
        </ul>
        <Section Heading="Mutation Testing — Are Your Tests Strong Enough?" Level="5">
            <p>
                Mutation testing helps verify your tests are strong enough to detect broken behavior. It works by making small changes (mutations) to your code and checking if your tests fail as expected.
            </p>
            <CodeSnippet Language="csharp" Description="Mutation Testing Example">
                // Original code
                return cart.Price * 0.9m;
                // Mutated code (by tool)
                return cart.Price * 0.8m;
                // If your test still passes, it’s too weak!
            </CodeSnippet>
            <p>Tools like Stryker.NET or Pitest (Java) automate mutation testing and help you strengthen your test suite.</p>
        </Section>
        <CalloutBox Type="info">
            Use your IDE’s “Extract Method” and “Rename” features—they’re safer and faster than manual edits.
        </CalloutBox>
    </Section>

    <Section Heading="Wrap-Up — Courage via Tests" Level="4">
        <p>
            Refactoring is a habit. TDD encourages frequent, safe refactors, cleaner designs, confidence in code, and higher quality with less fear. With tests as your safety net, refactoring becomes not just easy — but joyful. Next time you see a scary function, remember: write a test, refactor in small steps, and let your tests give you courage.
        </p>
    </Section>
</BlogContainer>

@page "/blog/tdd/expense-tracker-tdd-webapi"
@using TestArena.Blog.Common
@using TestArena.Blog.Common.NavigationUtils

@code {
    PageInfo? currentPage = SiteMap.Pages.FirstOrDefault(x => x.RelativePath == "/blog/tdd/expense-tracker-tdd-webapi");

    protected override void OnInitialized()
    {
        if (currentPage == null)
        {
            throw new InvalidOperationException("Page not found in SiteMap");
        }
        base.OnInitialized();
    }
}

<BlogContainer>
    <Header Title="@currentPage?.Header"
            Image="@(currentPage?.ArticleImage)"
            PublishedOn="@(currentPage?.PublishedOn ?? DateTime.UtcNow)"
            IsOlderThumbnailFormat="@(currentPage?.IsOlderThumbnailFormat ?? true)"
            Authors="Ajay Kumar">
    </Header>

    <Section Heading="Introduction">
        <p>
            In this article, we apply Test-Driven Development (TDD) to a real-world scenario: building a minimal Expense Tracker API in .NET. You'll learn how to break down the system, write tests for each layer, and keep dependencies controlled using mocks and fakes. We'll walk through the process step-by-step, showing code and design decisions at each stage.
        </p>
        <div class="tip">
            <b>Why TDD?</b> TDD helps you build reliable, maintainable code by writing tests before implementation. It keeps your design focused and your codebase flexible.
        </div>
    </Section>

    <Section Heading="Problem Statement">
        <ul>
            <li>Feature: Add a new expense</li>
            <li>Fields: title, amount, category, date</li>
            <li>API must validate input and store the expense</li>
        </ul>
    </Section>

    <Section Heading="System Breakdown">
        <ul>
            <li><b>API Controller</b> — Receives HTTP requests, validates input, returns responses</li>
            <li><b>Service Layer</b> — Contains business logic, enforces rules (e.g., amount > 0)</li>
            <li><b>Repository</b> — Persists data, can be faked for tests</li>
            <li><b>Models/DTOs</b> — Define structure for requests and domain objects</li>
        </ul>
        <div class="design-insight">
            <b>Design Insight:</b> Separating layers makes your code easier to test and maintain. Each layer has a clear responsibility.
        </div>
    </Section>

    <Section Heading="Test Strategy">
        <h5>Controller</h5>
        <ul>
            <li>Returns <b>400 Bad Request</b> for invalid data</li>
            <li>Returns <b>201 Created</b> for valid expense</li>
            <li>Calls service with correct values</li>
        </ul>
        <h5>Service</h5>
        <ul>
            <li>Rejects negative/zero amounts</li>
            <li>Rejects empty titles</li>
            <li>Creates a valid Expense model</li>
            <li>Calls repository once</li>
        </ul>
        <h5>Repository</h5>
        <ul>
            <li>Uses an in-memory fake for fast TDD cycles</li>
            <li>Tests basic persistence if needed</li>
        </ul>
        <div class="gotcha">
            <b>Tip:</b> Write tests for each layer separately. Use mocks for dependencies to keep tests focused.
        </div>
    </Section>

    <Section Heading="Step-by-Step TDD Implementation">
        <ol>
            <li><b>Write Service Tests First:</b> Start from core logic, force domain rules to emerge (amount > 0, title not empty, category known). Example:
                <CodeSnippet Language="csharp" Description="Service test for negative amount">
[Fact]
public void AddExpense_ShouldThrow_WhenAmountIsNegative()
{
    var repo = new InMemoryExpenseRepository();
    var service = new ExpenseService(repo);
    var dto = new ExpenseDto { Title = "Lunch", Amount = -5, Category = "Food", Date = DateTime.Today };
    Assert.Throws&lt;ArgumentException&gt;(() =&gt; service.AddExpense(dto));
}
                </CodeSnippet>
            </li>
            <li><b>Implement Service Logic:</b> Only write enough code to pass each failing test. Refactor frequently. Example:
                <CodeSnippet Language="csharp" Description="Service validation logic">
public Expense AddExpense(ExpenseDto dto)
{
    if (dto.Amount &lt;= 0) throw new ArgumentException("Amount must be positive");
    if (string.IsNullOrWhiteSpace(dto.Title)) throw new ArgumentException("Title required");
    var expense = new Expense { Title = dto.Title, Amount = dto.Amount, Category = dto.Category, Date = dto.Date };
    _repository.Add(expense);
    return expense;
}
                </CodeSnippet>
            </li>
            <li><b>Write Controller Tests:</b> Mock the service, validate input, assert correct HTTP status codes. Example:
                <CodeSnippet Language="csharp" Description="Controller test for valid expense">
[Fact]
public void AddExpense_Returns201_WhenValid()
{
    var mockService = new Mock&lt;IExpenseService&gt;();
    mockService.Setup(s =&gt; s.AddExpense(It.IsAny&lt;ExpenseDto&gt;())).Returns(new Expense());
    var controller = new ExpensesController(mockService.Object);
    var result = controller.AddExpense(new ExpenseDto { Title = "Lunch", Amount = 10, Category = "Food", Date = DateTime.Today });
    Assert.IsType&lt;CreatedResult&gt;(result);
}
                </CodeSnippet>
            </li>
            <li><b>Implement Controller:</b> Thin controllers, delegate to service, return consistent responses. Example:
                <CodeSnippet Language="csharp" Description="Controller implementation">
[HttpPost]
public IActionResult AddExpense([FromBody] ExpenseDto dto)
{
    try
    {
        var expense = _service.AddExpense(dto);
        return Created($"/api/expenses/{expense.Id}", expense);
    }
    catch (ArgumentException ex)
    {
        return BadRequest(ex.Message);
    }
}
                </CodeSnippet>
            </li>
            <li><b>Add Repository Fake:</b> Keep storage simple (list/dictionary), focus on TDD of logic, not infra setup. Example:
                <CodeSnippet Language="csharp" Description="In-memory repository">
public class InMemoryExpenseRepository : IExpenseRepository
{
    private readonly List&lt;Expense&gt; _expenses = new();
    public void Add(Expense expense) =&gt; _expenses.Add(expense);
    // ...
}
                </CodeSnippet>
            </li>
        </ol>
    </Section>

    <Section Heading="Example TDD Flow">
        <blockquote>
            <b>TDD Cycle:</b>
            <ul>
                <li><b>Red:</b> Write a failing test (e.g., service rejects negative amount)</li>
                <li><b>Green:</b> Implement minimal code to pass the test</li>
                <li><b>Refactor:</b> Clean up code, move logic to private methods if needed</li>
                <li>Repeat for each feature and layer</li>
            </ul>
        </blockquote>
    </Section>

    <Section Heading="Lessons Learned">
        <ul>
            <li>Start from the core business logic and let rules emerge from tests</li>
            <li>Write API/controller tests only after service logic is stable</li>
            <li>Mocks and stubs help isolate web layers from business rules</li>
            <li>Thin controllers, fat services: keep logic out of controllers</li>
            <li>Fakes are useful for fast TDD cycles and avoid infrastructure setup</li>
            <li>Refactor often—TDD encourages clean, maintainable code</li>
        </ul>
    </Section>

    <Section Heading="Summary">
        <p>
            This article demonstrated how to apply TDD to a real Web/API scenario by breaking the system into layers, writing tests for each layer, implementing only what is needed to make tests pass, and keeping dependencies controlled through mocks and fakes. By following this approach, you build robust, maintainable APIs and prepare for more advanced TDD topics.
        </p>
    </Section>
</BlogContainer>

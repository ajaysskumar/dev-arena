

@page "/blog/performance-testing-with-k6"
@using TestArena.Blog.Common
@using TestArena.Blog.Common.NavigationUtils


@code{
    PageInfo currentPage = SiteMap.Pages.FirstOrDefault(x => x.RelativePath == "/blog/performance-testing-with-k6");

    List<RenderFragment> keyGoals = new()
    {
        new RenderFragment(builder => builder.AddContent(0, "Measure response times")),
        new RenderFragment(builder => builder.AddContent(0, "Identify bottlenecks")),
        new RenderFragment(builder => builder.AddContent(0, "Ensure scalability")),
        new RenderFragment(builder => builder.AddContent(0, "Validate reliability under stress"))
    };

    List<RenderFragment> bestTimesToTest = new()
    {
        new RenderFragment(builder => builder.AddContent(0, "Before production releases to catch issues early.")),
        new RenderFragment(builder => builder.AddContent(0, "After major changes (features, refactoring, infrastructure).")),
        new RenderFragment(builder => builder.AddContent(0, "Periodically as part of CI/CD pipelines.")),
        new RenderFragment(builder => builder.AddContent(0, "When expecting traffic spikes (campaigns, launches, events)."))
    };

    List<RenderFragment> alternativesToK6 = new()
    {
        new RenderFragment(builder => builder.AddContent(0, "Apache JMeter: Mature, GUI-based, supports many protocols.")),
        new RenderFragment(builder => builder.AddContent(0, "Gatling: Scala-based, expressive DSL, detailed reports.")),
        new RenderFragment(builder => builder.AddContent(0, "Locust: Python-based, easy scripting, scalable.")),
        new RenderFragment(builder => builder.AddContent(0, "Artillery: JavaScript-based, CLI and YAML/JS scripting.")),
        new RenderFragment(builder => builder.AddContent(0, "NBomber: .NET-based, C#/F#, HTTP/WebSockets/gRPC, extensible."))
    };

    List<RenderFragment> k6Steps = new()
    {
        new RenderFragment(builder => builder.AddContent(0, "Install K6: On macOS, run 'brew install k6'.")),
        new RenderFragment(builder => builder.AddContent(0, "Write a K6 test script in JavaScript.")),
        new RenderFragment(builder => builder.AddContent(0, "Run your API and execute the K6 test.")),
        new RenderFragment(builder => builder.AddContent(0, "Optionally, generate an HTML report with k6-reporter."))
    };

    List<RenderFragment> k6Metrics = new()
    {
        new RenderFragment(builder => builder.AddContent(0, "checks: Percentage of successful checks (e.g., status 200).")),
        new RenderFragment(builder => builder.AddContent(0, "http_req_duration: Response time stats (avg, min, median, max, percentiles).")),
        new RenderFragment(builder => builder.AddContent(0, "http_reqs: Total number of HTTP requests made.")),
        new RenderFragment(builder => builder.AddContent(0, "vus: Number of virtual users."))
    };
}


<BlogContainer>

    <Header Title="@currentPage.Header"
        Image="@currentPage.ArticleImage"
        PublishedOn="@currentPage.PublishedOn"
        Authors="Ajay Kumar"
        Description="@currentPage.Header" />

    <Section Heading="Introduction" Level="5">
        <p>
            Ever tried grabbing a deal during a flash sale, only to watch the site crawl, your cart freeze, or the payment page vanish into a timeout abyss? You're not alone. Behind the scenes, APIs can be overwhelmed when many users hit the system at once — searching, clicking, refreshing, checking out. Without performance testing, these systems simply aren't ready for the chaos.
        </p>
        <p>
            Performance testing helps you simulate real-world traffic so you can find bottlenecks, protect user experience, and avoid production disasters.
        </p>
    </Section>

    <hr>
    <List Heading="Key goals" HeadingLevel="5" ChildContents="@keyGoals" />

    <Section Heading="Real-World Analogy" Level="5">
        <p>
            Think of your API like a busy coffee shop. Performance testing is like simulating hundreds of customers ordering coffee at once. You want to ensure the baristas (your API) can handle the rush without slowing down or making mistakes. K6 helps you create that simulated rush and measure how well your API copes.
        </p>
    </Section>

    <Section Heading="Major types of Performance Testing" Level="5">
        <p>
            There are several major kinds of performance testing, each with a specific purpose:
        </p>
        <ol>
            <li><strong>Load Testing:</strong> Measures how the system performs under expected user loads. The goal is to identify performance bottlenecks before the software application goes live.</li>
            <li><strong>Stress Testing:</strong> Determines the system’s robustness by testing it under extreme conditions, often beyond its expected capacity, to see how it handles high traffic or data processing.</li>
            <li><strong>Soak (Endurance) Testing:</strong> Checks the system’s stability and performance over an extended period, ensuring it can handle sustained use without degradation.</li>
            <li><strong>Spike Testing:</strong> Evaluates the system’s reaction to sudden large spikes in the load generated by users.</li>
            <li><strong>Scalability Testing:</strong> Assesses the system’s ability to scale up or down in response to increased or decreased load.</li>
        </ol>
    </Section>

    <Section Heading="When Should You Do Performance Testing?" Level="5">
        <p>Below are some common situations where performance tests are especially useful:</p>
        <List Heading="When to run perf tests" HeadingLevel="5" ChildContents="@bestTimesToTest" />
    </Section>

    <Section Heading="Why Use K6 for API Performance Testing?" Level="5">
        <p>
            <a href="https://k6.io/">K6</a> is an open-source, developer-centric tool for load testing APIs and web applications. It’s popular because:
        </p>
        <ul>
            <li>It uses JavaScript for scripting, making it accessible to most developers.</li>
            <li>It’s easy to automate and integrate into CI/CD pipelines.</li>
            <li>It provides rich metrics and reporting.</li>
            <li>It’s lightweight and fast.</li>
        </ul>
    </Section>

    <Section Heading="Other Popular Tools" Level="5">
        <p>
            While K6 is a great choice, there are several other widely used tools for API performance testing:
        </p>
        <ol>
        @foreach (var item in alternativesToK6)
        {
            <li>@item</li>
        }
        </ol>
        <p>
            Each tool has its strengths—choose based on your team’s language preferences, required features, and integration needs.
        </p>
    </Section>

    <p>
            Let’s walk through a real-world example using this repository.
        </p>
        <Section Heading="The Use Case: Most Borrowed Book API" Level="5">
            <p>
                We have a simple ASP.NET Core Web API that exposes a single endpoint <code>/mostborrowedbook</code>. This endpoint returns the book with the highest borrow count from an in-memory database seeded with thousands of records.
            </p>
            <Section Heading="API Code Example" Level="6">
                <CodeSnippet Language="csharp">
// Controller action
[HttpGet]
public async Task&lt;IActionResult&gt; Get() {
  var result = await _context.Books.Select(b =>new {
    b.Id,
    b.Title,
    b.Author,
    BorrowCount = b.Borrows.Count
  }).OrderByDescending(b =>b.BorrowCount).FirstOrDefaultAsync();

  if (result == null || result.BorrowCount == 0) return NotFound("No borrow records found.");

  return Ok(result);
}
                </CodeSnippet>
            </Section>
        </Section>
        <Section Heading="Setting Up K6 for Performance Testing" Level="5">
            <List Heading="Steps" HeadingLevel="5" ChildContents="@k6Steps" />
            <Section Heading="K6 Test Script Example" Level="6">
                <CodeSnippet Description="K6 Test Script Example" Language="javascript">
import http from 'k6/http';
import {
    check,
    sleep
} from 'k6';

export const options = {
    vus: 10, // number of virtual users
    duration: '10s', // test duration
};

export default function() {
    const res = http.get('http://localhost:5127/mostborrowedbook');
    check(res, {
        'status is 200': (r) => r.status === 200,
    });
    sleep(1);
}  
                </CodeSnippet>
                <ul>
                    <li><strong>vus</strong>: Number of virtual users (simulated clients)</li>
                    <li><strong>duration</strong>: How long the test runs</li>
                    <li><strong>check</strong>: Asserts that the response status is 200</li>
                    <li><strong>sleep</strong>: Waits 1 second between requests</li>
                </ul>
            </Section>
            <Section Heading="Running the API and the Test" Level="5">
                <CodeSnippet Language="bash">
cd MostBorrowedBookApi
dotnet run
                </CodeSnippet>
                <CodeSnippet Language="bash">
k6 run k6-mostborrowedbook.js
                </CodeSnippet>
            </Section>
            <Section Heading="Generate an HTML Report (Optional)" Level="5">
                <CodeSnippet Language="bash">
k6 run k6-mostborrowedbook.js --out json=results.json
npx k6-reporter results.json
                </CodeSnippet>
            </Section>
        </Section>

    <Section Heading="Demo Repository" Level="6">
            <p>
                The full demo code for this article is available at:
                <a href="https://github.com/ajaysskumar/API-Performance-Testing" target="_blank">ajaysskumar/API-Performance-Testing</a>
            </p>
            <p>
                This repository contains:
                <ul>
                    <li><strong>MostBorrowedBookApi</strong>: ASP.NET Core Web API with an in-memory database, seeded with thousands of books and borrows at startup. The endpoint <code>/mostborrowedbook</code> returns the book with the highest borrow count.</li>
                    <li><strong>k6-mostborrowedbook.js</strong>: K6 test script for load testing the API.</li>
                    <li><strong>run-perf-test.sh</strong>: Bash script to run the API and K6 test in one shot.</li>
                </ul>
            </p>
            <Section Heading="One-Shot Bash Script" Level="6">
                <p>
                    To run the API and the K6 test together, use the <code>run-perf-test.sh</code> script in the repository root. This script:
                </p>
                <ul>
                    <li>Checks if K6 is installed (installs via Homebrew on macOS if needed).</li>
                    <li>Starts the API in the background.</li>
                    <li>Waits for the API to start.</li>
                    <li>Runs the K6 test script.</li>
                    <li>Stops the API process after the test.</li>
                </ul>
                <p>
                    This makes it easy to run the full demo and performance test with a single command.
                </p>
            </Section>
        </Section>
    <Section Heading="Understanding K6 Metrics" Level="5">
        <p>
            After running the test, K6 outputs a summary like this:
        </p>
        <CodeSnippet Language="text">
Running K6 test...

          /\      |‾‾| /‾‾/   /‾‾/   
     /\  /  \     |  |/  /   /  /    
    /  \/    \    |     (   /   ‾‾\  
   /          \   |  |\  \ |  (‾)  | 
  / __________ \  |__| \__\ \_____/ .io

     execution: local
        script: k6-mostborrowedbook.js
        output: -

     scenarios: (100.00%) 1 scenario, 10 max VUs, 40s max duration (incl. graceful stop):
              * default: 10 looping VUs for 10s (gracefulStop: 30s)


     ✓ status is 200

     checks.........................: 100.00% ✓ 60       ✗ 0   
     data_received..................: 14 kB   1.2 kB/s
     data_sent......................: 5.8 kB  509 B/s
     http_req_blocked...............: avg=1.63ms   min=1µs      med=6µs      max=11.72ms p(90)=11.09ms p(95)=11.33ms
     http_req_connecting............: avg=589.03µs min=0s       med=0s       max=7.52ms  p(90)=2.06ms  p(95)=4.84ms 
     http_req_duration..............: avg=874.47ms min=758.66ms med=823.23ms max=1.18s   p(90)=1.15s   p(95)=1.17s  
       { expected_response:true }...: avg=874.47ms min=758.66ms med=823.23ms max=1.18s   p(90)=1.15s   p(95)=1.17s  
     http_req_failed................: 0.00%   ✓ 0        ✗ 60  
     http_req_receiving.............: avg=1.09ms   min=13µs     med=48µs     max=11.35ms p(90)=1.23ms  p(95)=10.06ms
     http_req_sending...............: avg=1.43ms   min=5µs      med=27.5µs   max=9.13ms  p(90)=8.22ms  p(95)=8.46ms 
     http_req_tls_handshaking.......: avg=0s       min=0s       med=0s       max=0s      p(90)=0s      p(95)=0s     
     http_req_waiting...............: avg=871.94ms min=758.58ms med=823.17ms max=1.17s   p(90)=1.13s   p(95)=1.16s  
     http_reqs......................: 60      5.302087/s
     iteration_duration.............: avg=1.87s    min=1.75s    med=1.82s    max=2.2s    p(90)=2.18s   p(95)=2.19s  
     iterations.....................: 60      5.302087/s
     vus............................: 10      min=10     max=10
     vus_max........................: 10      min=10     max=10


running (11.3s), 00/10 VUs, 60 complete and 0 interrupted iterations
default ✓ [======================================] 10 VUs  10s
        </CodeSnippet>
        <p>
            Here’s a breakdown of the key metrics:
        </p>
        <table class="table table-bordered table-striped" style="margin-top:1rem;">
            <thead>
                <tr>
                    <th>Metric</th>
                    <th>Explanation</th>
                </tr>
            </thead>
            <tbody>
                <tr><td><code>checks</code></td><td>Percentage and count of successful checks (assertions), e.g., status 200.</td></tr>
                <tr><td><code>data_received</code></td><td>Total and average amount of data received from the server.</td></tr>
                <tr><td><code>data_sent</code></td><td>Total and average amount of data sent to the server.</td></tr>
                <tr><td><code>http_req_blocked</code></td><td>Time spent waiting for a free TCP connection slot (blocked by OS or client limits).</td></tr>
                <tr><td><code>http_req_connecting</code></td><td>Time spent establishing TCP connections to the server.</td></tr>
                <tr><td><code>http_req_duration</code></td><td>Total time for request (from start to end, including waiting, sending, receiving).</td></tr>
                <tr><td><code>{ expected_response:true }</code></td><td>Duration for requests that received expected responses (usually status 200).</td></tr>
                <tr><td><code>http_req_failed</code></td><td>Percentage and count of failed HTTP requests.</td></tr>
                <tr><td><code>http_req_receiving</code></td><td>Time spent receiving response data from the server.</td></tr>
                <tr><td><code>http_req_sending</code></td><td>Time spent sending request data to the server.</td></tr>
                <tr><td><code>http_req_tls_handshaking</code></td><td>Time spent on TLS/SSL handshake (if using HTTPS).</td></tr>
                <tr><td><code>http_req_waiting</code></td><td>Time spent waiting for server to respond after sending request (server processing time).</td></tr>
                <tr><td><code>http_reqs</code></td><td>Total number of HTTP requests made and average per second.</td></tr>
                <tr><td><code>iteration_duration</code></td><td>Total time taken for each test iteration (one virtual user run).</td></tr>
                <tr><td><code>iterations</code></td><td>Total number of test iterations and average per second.</td></tr>
                <tr><td><code>vus</code></td><td>Number of active virtual users during the test.</td></tr>
                <tr><td><code>vus_max</code></td><td>Maximum number of virtual users reached during the test.</td></tr>
            </tbody>
        </table>
        <p>
            If you use k6-reporter, you’ll get an HTML file with charts and detailed breakdowns.
        </p>
    </Section>

    <Section Heading="Conclusion" Level="5">
        <p>
            Performance testing is essential for delivering reliable APIs. K6 makes it easy to simulate real-world load, catch bottlenecks, and ensure your API is production-ready. With a simple setup and powerful reporting, it’s a great tool for developers and DevOps alike.
        </p>
        <p>
            <a href="https://github.com/ajaysskumar/API-Performance-Testing"><strong>Sample code with runnable scripts are present in the code repository</strong></a>  </p>
    </Section>
</BlogContainer>
